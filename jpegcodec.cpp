#include "jpegcodec.h"

#include <queue>
#include <cmath>
#include <cstdlib>
#include <iostream>
#include <fstream>

#include "bitmap.h"
#include "bitdatabuilder.h"

namespace
{
const int dcHuffmanLength[12] = { 2,3,3,3,3,3,4,5,6,7,8,9 };
const int dcHuffmanTable[12] = {
    0x000,0x002,0x003,0x004,0x005,0x006,
    0x00e,0x01e,0x03e,0x07e,0x0fe,0x1fe
};

const int acHuffmanLength[256] = {
     4, 2, 2, 3, 4, 5, 7, 8,
    10,16,16, 0, 0, 0, 0, 0,
     0, 4, 5, 7, 9,11,16,16,
    16,16,16, 0, 0, 0, 0, 0,
     0, 5, 8,10,12,16,16,16,
    16,16,16, 0, 0, 0, 0, 0,
     0, 6, 9,12,16,16,16,16,
    16,16,16, 0, 0, 0, 0, 0,
     0, 6,10,16,16,16,16,16,
    16,16,16, 0, 0, 0, 0, 0,
     0, 7,11,16,16,16,16,16,
    16,16,16, 0, 0, 0, 0, 0,
     0, 7,12,16,16,16,16,16,
    16,16,16, 0, 0, 0, 0, 0,
     0, 8,12,16,16,16,16,16,
    16,16,16, 0, 0, 0, 0, 0,
     0, 9,15,16,16,16,16,16,
    16,16,16, 0, 0, 0, 0, 0,
     0, 9,16,16,16,16,16,16,
    16,16,16, 0, 0, 0, 0, 0,
     0, 9,16,16,16,16,16,16,
    16,16,16, 0, 0, 0, 0, 0,
     0,10,16,16,16,16,16,16,
    16,16,16, 0, 0, 0, 0, 0,
     0,10,16,16,16,16,16,16,
    16,16,16, 0, 0, 0, 0, 0,
     0,11,16,16,16,16,16,16,
    16,16,16, 0, 0, 0, 0, 0,
     0,16,16,16,16,16,16,16,
    16,16,16, 0, 0, 0, 0, 0,
    11,16,16,16,16,16,16,16,
    16,16,16, 0, 0, 0, 0, 0
};

const int acHuffmanTable[256] = {
    0x000a,0x0000,0x0001,0x0004,0x000b,0x001a,0x0078,0x00f8,
    0x03f6,0xff82,0xff83,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x000c,0x001b,0x0079,0x01f6,0x07f6,0xff84,0xff85,
    0xff86,0xff87,0xff88,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x001c,0x00f9,0x03f7,0x0ff4,0xff89,0xff8a,0xff8b,
    0xff8c,0xff8d,0xff8e,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x003a,0x01f7,0x0ff5,0xff8f,0xff90,0xff91,0xff92,
    0xff93,0xff94,0xff95,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x003b,0x03f8,0xff96,0xff97,0xff98,0xff99,0xff9a,
    0xff9b,0xff9c,0xff9d,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x007a,0x07f7,0xff9e,0xff9f,0xffa0,0xffa1,0xffa2,
    0xffa3,0xffa4,0xffa5,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x007b,0x0ff6,0xffa6,0xffa7,0xffa8,0xffa9,0xffaa,
    0xffab,0xffac,0xffad,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x00fa,0x0ff7,0xffae,0xffaf,0xffb0,0xffb1,0xffb2,
    0xffb3,0xffb4,0xffb5,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x01f8,0x7fc0,0xffb6,0xffb7,0xffb8,0xffb9,0xffba,
    0xffbb,0xffbc,0xffbd,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x01f9,0xffbe,0xffbf,0xffc0,0xffc1,0xffc2,0xffc3,
    0xffc4,0xffc5,0xffc6,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x01fa,0xffc7,0xffc8,0xffc9,0xffca,0xffcb,0xffcc,
    0xffcd,0xffce,0xffcf,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x03f9,0xffd0,0xffd1,0xffd2,0xffd3,0xffd4,0xffd5,
    0xffd6,0xffd7,0xffd8,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x03fa,0xffd9,0xffda,0xffdb,0xffdc,0xffdd,0xffde,
    0xffdf,0xffe0,0xffe1,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x07f8,0xffe2,0xffe3,0xffe4,0xffe5,0xffe6,0xffe7,
    0xffe8,0xffe9,0xffea,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0xffeb,0xffec,0xffed,0xffee,0xffef,0xfff0,0xfff1,
    0xfff2,0xfff3,0xfff4,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x07f9,0xfff5,0xfff6,0xfff7,0xfff8,0xfff9,0xfffa,0xfffb,
    0xfffc,0xfffd,0xfffe,0x0000,0x0000,0x0000,0x0000,0x0000
};

    const int quantTable[8][8] = { 16, 11, 10, 16, 24, 40, 51, 61,
                                   12, 12, 14, 19, 26, 58, 60, 55,
                                   14, 13, 16, 24, 40, 57, 69, 56,
                                   14, 17, 22, 29, 51, 87, 80, 62,
                                   18, 22, 37, 56, 68, 109, 103, 77,
                                   24, 35, 55, 64, 81, 104, 113, 92,
                                   49, 64, 78, 87, 103, 121, 120, 101,
                                   72, 92, 95, 98, 112, 100, 103, 99 };

    const int zigZagOrder[8][8] = {0, 1, 5, 6, 14, 15, 27, 28,
                                   2, 4, 7, 13, 16, 26, 29, 42,
                                   3, 8, 12, 17, 25, 30, 41, 43,
                                   9, 11, 18, 24, 31, 40, 44, 53,
                                   10, 19, 23, 32, 39, 45, 52, 54,
                                   20, 22, 33, 38, 46, 51, 55, 60,
                                   21, 34, 37, 47, 50, 56, 59, 61,
                                   35, 36, 48, 49, 57, 58, 62, 63};

    int codeLength(int x) {
        x = abs(x);

        for (int i = 8 * sizeof(int) - 1; i >= 0; --i) {
            if (x & (1 << i))
                return i + 1;
        }

        return 0;
    }

    void moveZigZag(int &x, int &y, int n)
    {
        if (y < n - 1) {
            x = fmax(0, x - 1);
            y = y + 1;
        } else {
            x = x + 1;
        }
    }
}


JpegCodec::JpegCodec()
{
}

std::pair<std::vector<int>, int> JpegCodec::encode(const Bitmap &bmp)
{
    if (!bmp.isValid())
        return std::pair<std::vector<int>, int>();

    const int size = bmp.width() * bmp.height();

    char y[size];
    char cb[size];
    char cr[size];

    const Pixel *data = bmp.data();
    for (int i = 0; i < size; ++i) {
        const Pixel &p = data[i];
        y[i] = 0.299 * p.red() + 0.587 * p.green() + 0.114 * p.blue() - 128;
        cb[i] = -0.1687 * p.red() - 0.3313 * p.green() + 0.5 * p.blue() + 128 - 128;
        cr[i] = 0.5 * p.red() - 0.4187 * p.green() - 0.0813 * p.blue() + 128 - 128;
    }

    BitDataBuilder builder;
    dct(y, bmp.width(), bmp.height(), builder);
    return builder.data();
}

void JpegCodec::dct(char *data, int width, int height, BitDataBuilder &builder)
{
    const int blockSize = 8;
    const int bufferSize = blockSize * blockSize;

    char byteBuffer[bufferSize];
    int intBuffer1[bufferSize];
    int intBuffer2[bufferSize];

    for (int i = 0; i < ceil(height / blockSize); ++i) {
        for (int j = 0; j < ceil(width / blockSize); ++j) {
            memset(byteBuffer, 0, bufferSize);

            for (int k = 0; k < blockSize; ++k) {
                if (i * blockSize + k >= height)
                    break;

                const int pos = (i * blockSize + k) * width + j * blockSize;
                const int copySize = fmin(blockSize, width - j * blockSize);
                memcpy(byteBuffer + blockSize * k, data + pos, copySize);
            }

            dctBlock(byteBuffer, intBuffer1, blockSize);
            quantizeBlock(intBuffer1, blockSize);

            for (int a = 0; a < blockSize; ++a) {
                for (int b = 0; b < blockSize; ++b) {
                    std::cout << intBuffer1[a * blockSize + b] << " ";
                }
                std::cout << std::endl;
            }

            const int len = runLengthEncoding(intBuffer1, intBuffer2, blockSize);

            for (int a = 0; a < len; ++a) {
                std::cout << intBuffer2[a] << " ";
            }
            std::cout << std::endl;

            const int dcCodeLength = codeLength(intBuffer2[0]);
            int data =  intBuffer2[0];
            if (data < 0)
                data = ~(-data);

            std::cout << "DC " << dcHuffmanTable[dcCodeLength] << " " << dcHuffmanLength[dcCodeLength] << std::endl;
            std::cout << data << " " << dcCodeLength << std::endl;

            builder.appendData(dcHuffmanTable[dcCodeLength], dcHuffmanLength[dcCodeLength]);
            builder.appendData(data, dcCodeLength);

            variableLenghtHuffmanCoding(intBuffer2, len, builder);
        }
    }
}

void JpegCodec::dctBlock(const char *input, int *output, int blockSize)
{
    for (int v = 0; v < blockSize; ++v) {
        for (int u = 0; u < blockSize; ++u) {
            output[v * blockSize + u] = dctPixel(input, blockSize, u, v);
        }
    }
}

void JpegCodec::quantizeBlock(int *data, int blockSize)
{
    if (blockSize != 8)
        return;

    for (int i = 0; i < 8; ++i) {
        for (int j = 0; j < 8; ++j) {
            data[i * blockSize + j] = round(data[i * blockSize + j] / quantTable[i][j]);
        }
    }
}

double JpegCodec::dctPixel(const char *data, int blockSize, int u, int v)
{
    double val = 0;

    for (int x = 0; x < blockSize; ++x) {
        for (int y = 0; y < blockSize; ++y) {
            val += data[y * blockSize + x] * cos((2 * x + 1) * u * M_PI / 16.0) * cos((2 * y + 1) * v * M_PI / 16.0);
        }
    }

    val *= (u == 0 && v == 0) ? 0.125 : 0.25;
    return val;
}

int JpegCodec::runLengthEncoding(int *input, int *output, int blockSize)
{
    int x = 0;
    int y = 0;

    int total = 0;
    int zeros = 0;
    const int maxZeros = 15;

    std::queue<int> values;

    while (x < blockSize && y < blockSize) {
        if (x == 0 && y == 0) {
            output[total++] = input[y * blockSize + x];
        } else {
            if (input[y * blockSize + x] == 0) {
                ++zeros;

                if (zeros == maxZeros) {
                    values.push(maxZeros);
                    values.push(0);
                    zeros = 0;
                }
            } else {
                while (!values.empty()) {
                    output[total++] = values.front();
                    values.pop();
                }

                output[total++] = zeros;
                output[total++] = input[y * blockSize + x];
                zeros = 0;
            }
        }

        if ((x + y) & 1)
            moveZigZag(x, y, blockSize);
        else
            moveZigZag(y, x, blockSize);
    }

    if (input[63] == 0) {
        output[total++] = 0;
        output[total++] = 0;
    }

    return total;
}

void JpegCodec::variableLenghtHuffmanCoding(int *input, int size, BitDataBuilder &builder)
{
    for (int i = 1; i < size; i += 2) {
        const int zeros = input[i];
        const int len = codeLength(input[i + 1]);
        builder.appendData(acHuffmanTable[(zeros << 4) + len], acHuffmanLength[(zeros << 4) + len]);
        int data =  input[i + 1];
        if (data < 0)
            data = ~data;

        builder.appendData(data, len);
    }
}

void JpegCodec::writeJpegToFile(const char *filename, const std::pair<std::vector<int>, int> &data)
{
    std::ofstream out(filename, std::ios_base::out | std::ios_base::binary);
    /*out << char(0xff) << char(0xd8); // SOI
    out << char(0xff) << char(0xe0); // APP

    out << char(0x00) << char(0x07) << "TEST";

    out << char(0xff) << char(0xdb); // DQT
    out << char(0x00) << char(0x43) << char(0x00);

    for (int i = 0; i < 8; ++i) {
        for (int j = 0; j < 8; ++j) {
            out << char(quantTable[i][j]);
        }
    }

    out << char(0xff) << char(0xc0); // SOF
    out << char(0x00) << char(0x0b);
    out << char(0x08); // 8bit sample
    out << char(0x00) << char(0x08); // height
    out << char(0x00) << char(0x08); // width
    out << char(0x01); // only gray channel
    out << char(0x01) << char(0x11) << char(0x00); // gray channel data*/

    /*out << char(0xff) << char(0xc4); // DHT
    out << char(0x00) << char(0x1f); // 31 byte follow
    out << char(0x00); // HT info: 0..3bits - HT number, 4 bit - HT type, 5-7 must be 0

    const char[16] standardDcHuffTable = {0x00, 0x01, 0x05, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
    */

    /*const unsigned char huffTables[] = {0xFF, 0xC4, 0x00, 0x1F, 0x00, 0x00, 0x01, 0x05, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00,
                               0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                               0x09, 0x0A, 0x0B, 0xFF, 0xC4, 0x00, 0xB5, 0x10, 0x00, 0x02, 0x01, 0x03, 0x03, 0x02, 0x04,
                               0x03, 0x05, 0x05, 0x04, 0x04, 0x00, 0x00, 0x01, 0x7D, 0x01, 0x02, 0x03, 0x00, 0x04, 0x11,
                               0x05, 0x12, 0x21, 0x31, 0x41, 0x06, 0x13, 0x51, 0x61, 0x07, 0x22, 0x71, 0x14, 0x32, 0x81,
                               0x91, 0xA1, 0x08, 0x23, 0x42, 0xB1, 0xC1, 0x15, 0x52, 0xD1, 0xF0, 0x24, 0x33, 0x62, 0x72,
                               0x82, 0x09, 0x0A, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x34,
                               0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x53,
                               0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A,
                               0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89,
                               0x8A, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6,
                               0xA7, 0xA8, 0xA9, 0xAA, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xC2, 0xC3,
                               0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9,
                               0xDA, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xF1, 0xF2, 0xF3, 0xF4,
                               0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA };

    for (int i = 0; i < sizeof(huffTables); ++i) {
        out << huffTables[i];
    }

    out << char(0xff) << char(0xda); // start data*/

    const unsigned char xxx[] = {0xFF, 0xD8, 0xFF, 0xE0, 0x00, 0x10, 0x4A, 0x46, 0x49, 0x46, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0xFF, 0xDB, 0x00, 0x43, 0x00, 0x10, 0x0B, 0x0C, 0x0E, 0x0C, 0x0A, 0x10, 0x0E, 0x0D, 0x0E, 0x12, 0x11, 0x10, 0x13, 0x18, 0x28, 0x1A, 0x18, 0x16, 0x16, 0x18, 0x31, 0x23, 0x25, 0x1D, 0x28, 0x3A, 0x33, 0x3D, 0x3C, 0x39, 0x33, 0x38, 0x37, 0x40, 0x48, 0x5C, 0x4E, 0x40, 0x44, 0x57, 0x45, 0x37, 0x38, 0x50, 0x6D, 0x51, 0x57, 0x5F, 0x62, 0x67, 0x68, 0x67, 0x3E, 0x4D, 0x71, 0x79, 0x70, 0x64, 0x78, 0x5C, 0x65, 0x67, 0x63, 0xFF, 0xC0, 0x00, 0x0B, 0x08, 0x00, 0x08, 0x00, 0x08, 0x01, 0x01, 0x11, 0x00, 0xFF, 0xC4, 0x00, 0x1F, 0x00, 0x00, 0x01, 0x05, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0xFF, 0xC4, 0x00, 0xB5, 0x10, 0x00, 0x02, 0x01, 0x03, 0x03, 0x02, 0x04, 0x03, 0x05, 0x05, 0x04, 0x04, 0x00, 0x00, 0x01, 0x7D, 0x01, 0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12, 0x21, 0x31, 0x41, 0x06, 0x13, 0x51, 0x61, 0x07, 0x22, 0x71, 0x14, 0x32, 0x81, 0x91, 0xA1, 0x08, 0x23, 0x42, 0xB1, 0xC1, 0x15, 0x52, 0xD1, 0xF0, 0x24, 0x33, 0x62, 0x72, 0x82, 0x09, 0x0A, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFF, 0xDA};
    for (int i = 0; i < sizeof(xxx); ++i) {
        out << xxx[i];
    }

    /*const unsigned char yyy[] = {0x00, 0x08, 0x01, 0x01, 0x00, 0x00, 0x3F, 0x00, 0xFD, 0x0E, 0xF1, 0x76, 0xA1, 0xA8, 0x59, 0xDE, 0xE9, 0x3A, 0x67, 0x87, 0xF4, 0xCD, 0x60, 0xDC, 0xC7, 0x70, 0xB3, 0xC1, 0x1D, 0xB5, 0xA0, 0x8F, 0x4F, 0x8A, 0x28, 0x89, 0x49, 0x23, 0x95, 0xF7, 0xC6, 0xA5, 0x5D, 0x19, 0x8A, 0x21, 0x63, 0xF3, 0x08, 0xDB, 0x18, 0x18, 0x3F};
    for (int i = 0; i < sizeof(yyy); ++i) {
        out << yyy[i];
    }*/

    out << char(0x00) << char(0x08) << char(0x01) << char(0x01) << char(0x00);
    out << char(0x00) << char(0x3f) << char(0x00);

    for (int i = 0; i + 1 < data.first.size(); ++i) {
        const int x = data.first[i];

        char buffer[4];
        memcpy(buffer, &x, sizeof(int));

        for (int i = sizeof(buffer) - 1; i >= 0; --i) {
            out << buffer[i];
            std::cout << int((unsigned char)buffer[i]) << " ";

            if (buffer[i] == char(0xff)) {
                out << (char)0x00;
                std::cout << 0 << " ";
            }
        }
    }

    const int diff = ceil((data.second - (data.first.size() - 1) * sizeof(int) * 8) / 8.0);
    const int intData = data.first[data.first.size() - 1];
    const unsigned char tailMask = (1 << (8 - data.second % 8)) - 1;

    std::cout << "DIFF " << diff << std::endl;

    for (int i = 0; i < diff; ++i) {
        char c[sizeof(int)];
        memcpy(c, &intData, sizeof(int));

        char v = c[sizeof(int) - i - 1];
        if (i + 1 == diff)
            v |= tailMask;

        out << v;
        std::cout << "X " << int((unsigned char)v) << " ";
    }

    std::cout << std::endl;

    out << char(0xff) << char(0xd9);
    out.close();
}

/*
 *
 *
 *
 */
